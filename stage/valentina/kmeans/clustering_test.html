<!-- <script src="clustering.js">
var dataset = [
  [1,1],[0,1],[1,0],
  [10,10],[10,13],[13,13],
  [54,54],[55,55],[89,89],[57,55]
];

var clustering = ('density-clustering');
var kmeans = new KMEANS();
// parameters: 3 - number of clusters
var clusters = kmeans.run(dataset, 3);
console.log(clusters);

</script>   -->


<!doctype html>
<html>

<head>
  <title>Clustering</title>
<link href="../stile.css" rel="stylesheet" type="text/css">

<body>
<h1>Clustering: K-Means, DBSCAN, OPTICS</h1>

<div id=big_container>
<span id=grafico>    <!-- 550 500-->
  <canvas id="NPGcanvas" width="700" height="650" onclick="eventClick(event)">Browser not supported for Canvas. Get a real browser.</canvas>
</span>

<span id=destra>
<p>Select your algorithms:</p>
<div id="algo">
<input id="button_kmeans" type="button" value="K-Means" onclick="setLearner(0)">
<input id="button_DBSCAN" type="button" value="DBSCAN" onclick="setLearner(1)">
<input id="button_OPTICS" type="button" value="OPTICS" onclick="setLearner(2)">
</div>

<p>Select your actions:</p>
<div id="azioni">
<input id="button_train_km" type="button" value="Train" onclick="train()">
<input id="button_sql_km" type="button" value="Sql" onclick="sql()">
<input id="button_ncluster_km" type="button" value="Cluster" onclick="nCluster()">
<input id="button_matrix_km" type="button" value="Confusion Matrix" onclick = "conf_matrix()">
<!--<input id="button_prob_km" type="button" value="Prob(Y)" onclick="prob()">
<input id="button_odds_km" type="button" value="Odds(Y)" onclick="odds()">  -->
<input id="button_valMod_km" type="button" value="Valutazioni Modello" onclick="valMod()">
<input id="button_goodMod_km" type="button" value="Efficenza Modello" onclick="goodMod()">
<input id="button_classErr_km" type="button" value="Prob classificazione errata" onclick="class_err()">
</div>

<div id="result_km">
<div id="info"></div>
<div id="sql"></div>
<div id="ncluster"></div>

<div id="confusion_matrix_km"></div>
<div id="prob_km"></div>
<!--<div id="odds_km"></div>
<div id="valMod_km"></div> -->
<div id="goodMod_km"></div>
<div id="class_err_km"></div>
</div>

<input id="button_show_km" type="button" value="Details" onclick = "show()">
<input id="button_removeAdd_km" type="submit" value="Remove Point" onclick="removeDataPoint()">
<input id="button_clean_km" type="submit" value="Clean Desk" onclick="cleanGrafico()">

<div id="show"></div>
</span></div>

<script src="../ZMLBase.js"></script>

<script src="clustering.js"></script>
<script src="clustering_vale.js"></script>
	
<script>
// variabili per la gestione del canvas
var canvas = document.getElementById("NPGcanvas")
var ctx = canvas.getContext('2d');
var WIDTH=700,HEIGHT=650,ss=50.0  //<!-- 550 500-->

// variabili per il learner
var data=[];               // valori delle x dei punti disegnati
var values=[];               // valori delle y dei punti disegnati           
var trained=false;

var learners=[new KmeansLearner(3), new DbscanLearner(3), new OpticsLearner(3)];
var lrn=learners[0]
var mdl=null

function addDataPoint(x,y,c){
  // add datapoint at location of click
  data.push([(x-WIDTH/2)/ss]);
  values.push(-(y-HEIGHT/2)/ss);
  trained=false
  Redraw()
}

function removeDataPoint(x,y,c) {
  // remove datapoint at location of click
  data.pop([(x-WIDTH/2)/ss]);
  values.pop(-(y-HEIGHT/2)/ss); // delete last element: coda della lista
  trained=false
  Redraw()
}

function mouseClick(x,y,shift){
  addDataPoint(x,y,(shift?1:-1))
}

function eventClick(e) {    
  //get position of cursor relative to top left of canvas
  var x = e.pageX;
  var y = e.pageY;
  var r = canvas.getBoundingClientRect();
  x -= r.left+window.scrollX;
  y -= r.top+window.scrollY;  
  //call user-defined callback
  mouseClick(x, y, e.shiftKey);
}

function drawCircle(x, y, r){
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI*2, true); 
  ctx.closePath();
  ctx.stroke();
  ctx.fill();
}

function Redraw(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);
      
  if (trained) {    // clustering
    for(var i=0;i<data.length;i++){
      var p = mdl.predictJS([(x-WIDTH/2)/ss]); // predizione
      if (p == 1)  
        ctx.fillStyle = 'rgb(255, 51, 51)';  //rosso
      else if (p == 2)  
        ctx.fillStyle = 'rgb(51, 153, 255)';  //azzurro 
      else 
        ctx.fillStyle = 'rgb(153, 255, 51)';   //verde
       
    drawCircle(data[i][0]*ss+WIDTH/2, data[i][1]*ss+HEIGHT/2, 3);  
    }    

  }
  
  ctx.beginPath();   // draw axes
  ctx.strokeStyle = 'rgb(50,50,50)';
  ctx.lineWidth = 1;
  ctx.moveTo(0, HEIGHT/2);
  ctx.lineTo(WIDTH, HEIGHT/2);
  ctx.moveTo(WIDTH/2, 0);
  ctx.lineTo(WIDTH/2, HEIGHT);
  ctx.stroke();
  
  ctx.fillStyle = 'rgb(255, 153, 255)' // draw data points
  for(var i=0;i<data.length;i++){
    drawCircle(data[i][0]*ss+WIDTH/2, -values[i]*ss+HEIGHT/2, 3);
  }
}

Redraw()

function cleanGrafico(){

  ctx.clearRect(0,0,WIDTH,HEIGHT); /*cancello assi*/
	trained = false;

	ctx.beginPath(); /*ricreo assi*/
	ctx.strokeStyle = 'rgb(50,50,50)';
  ctx.lineWidth = 1;
  ctx.moveTo(0, HEIGHT/2);
  ctx.lineTo(WIDTH, HEIGHT/2);
  ctx.moveTo(WIDTH/2, 0);
  ctx.lineTo(WIDTH/2, HEIGHT);
  ctx.stroke();

	labels = [];  /*cancello i punti vecchi*/
	data = [];
	show();


  train();
  sql();
  nCluster();
  conf_matrix();
  prob();
 	odds();
  valMod();
  goodMod();
  class_err();
}

Redraw()

function train(){
  lrn.resetData()
  for(var i=0;i<data.length;i++){
    lrn.addData(labels[i],data[i])
  }
  lrn.train()
  mdl=lrn.getModel()
  trained=true
  Redraw()
}

function sql(){
  if (trained)
    document.getElementById("sql").innerHTML="<b>SQL =</b> " + mdl.predictSQL();

  else
	  show();
}

function nCluster(){
  if (trained)
    document.getElementById("ncluster").innerHTML="<b>Cluster: </b>" + lrn.getNumberOfluster();

    else
	    show();
}

function conf_matrix(){

  if(!trained)
    show();

  else{
    var tp = 0, tn = 0, fn = 0, fp = 0;
    var n = data.length;

    for (var i = 0; i < n; i++){

    	if (labels[i] == mdl.predictJS(data[i])){ // reali e predetti uguali
          if(labels[i] == 1) tp++;
          else tn++;
        }

    	else{ // reali e predetti diversi
			if(labels[i] == 1) fn++;
            else fp++;
       }
    }

  document.getElementById("confusion_matrix_rf").innerHTML = "<b>Confusion Matrix</b>" + "<br/>" +
                                                         "+ -------------------------------------- +  <br/>" + "<br/>" +
                                                         "<b>TRUE POSITIVE </b> " + tp + " " + "<b> FALSE NEGATIVE</b> "+ " " + fn + " <br/>" + " <br/>"+
                                                         "<b>FALSE POSITIVE</b> " + fp + " " + "<b>TRUE NEGATIVE</b> " + " " + tn + " <br/>" +  "<br/>" +
                                                         " + -------------------------------------- + ";
  } 
}                  

function prob(){

  if(!trained)
	show();
 
  else {
    var n = data.length, classeA = 0, classeB = 0;

    for (var i = 0; i < n; i++){
      if (labels[i] == 1) classeA++;
      else classeB++;
    }
    //document.write(classeA + " " + classeB);

    var probA = (classeA / n) * 100;  //probabilita in % di appartenere alle classi -1 ed 1
    var probB = (classeB / n) * 100; 

    document.getElementById("prob_rf").innerHTML = "<b>Prob (Y = 1): </b>" + probA.toFixed(4) + "% " + " ; " + " " +
                                                   "<b> Prob (Y = -1): </b>" + probB.toFixed(4) + "% ";
  }
}

function odds(){

  if(!trained)
    show();

  else{
    var n = data.length;
    var classeA = 0, classeB = 0;

  for (var i = 0; i < n; i++){
	if (labels[i] == 1) classeA++;
    else classeB++;
  }
  //document.write(classeA + " " + classeB);

  var oddsA =  classeA / classeB; // odds: relazione fra A e B
  var oddsB =  classeB / classeA;  // odds: relazione fra B ed A

  document.getElementById("odds_rf").innerHTML = "<b>Odds (Y = 1): </b>" + oddsA.toFixed(4) + " ; " +
                                                 "<b> Odds (Y = -1): </b>" + oddsB.toFixed(4);
  }
}

function valMod(){
  if (!trained)
    show();

  else{
    var tp = 0, tn = 0, fn = 0, fp = 0;
	var n = data.length;
	
    for (var i = 0; i < n; i++){

    	if (labels[i] == mdl.predictJS(data[i])){ // reali e predetti uguali  
          if(labels[i] == 1) tp++;
          else tn++;
        }
       
    	else{ // reali e predetti diversi
			if(labels[i] == 1) fn++;
            else fp++;
		}
    }
		//console.log(n);

      var er_rate = (fp + fn) / n;  //ottimo = 0 , male = 1;
      var prec = tp / (tp + fp);
      var acc = (tp + tn) / n;  
      var recall  =  tp / (tp + fn);
      var spec = tn / (tn + fp);  //ottimo = 1 , male = 0;
      var fp_rate = 1 - spec;  //ottimo = 0 , male = 1;
      var f_score = (2 * recall * prec) / (recall + prec); //ottimo = 1 , male = 0;

  document.getElementById("valMod_rf").innerHTML = "<br/>" + "<b>Error rate = </b>" + er_rate.toFixed(4) + " ; " +  
                                                   "<b>Precisione = </b>" + prec.toFixed(4) + " ; " +
                                                   "<b>Accuratezza = </b>" + acc.toFixed(4) + " ; " +
                                                   "<b>Recall = </b>" + recall.toFixed(4) +  "<br/>" +
                                                   "<b>Specificita' = </b>" + spec.toFixed(4)  + " ; " +
                                                   "<b>False Positive rate = </b>" + fp_rate.toFixed(4) + " ; " +
                                                  "<b>F-Score = </b>" + f_score.toFixed(4);
  return acc;
}
}                     

function goodMod(){ //efficienza predittiva = (er. senza mod - er. col mod) / er. senza mod
                    // er. senza mod = sum [fi * ((n - fi) / n) ]  ,  dove   fi = n. casi in i
  if(!trained)
    show();

  else{
    var n = data.length, err = 0;

    for (var i = 0; i < n; i++){

      if (labels[i] != mdl.predictJS(data[i])) // reali e predetti diversi -> errori col modello
         err++; 
	}
	
	//console.log(err)

  //err. senza modello
    var np = 0, nn = 0; // #casi in 1 e in -1

    for (var i = 0; i < n; i++){
	  if (labels[i] == 1) np++;
	  else nn++;
    }
     //console.log(np)

	var er_NoMod1 = [np * [(n - np) / n]];
	var er_NoMod2 = [nn * [(n - nn) / n]];
	var er_NoMod = er_NoMod1[0] + er_NoMod2[0];

  // document.write(er_NoMod1 + " + " + er_NoMod2 + " = " + er_NoMod);
    var good = (er_NoMod - err) / er_NoMod;

    document.getElementById("goodMod_rf").innerHTML = "<b> Efficienza del modello = </b> " + good.toFixed(4);
  }
}

function class_err(){
  var acc = valMod();

  var er = 1 - acc ;
  document.getElementById("class_err_rf").innerHTML = "<b> Probabilita' classificazione errata = </b> " + er.toFixed(4);

}

function show(){

  if (!trained) 
    document.getElementById("show").innerHTML = "<b>Mouse click add data point, then select trees's number and train your model :-)</b>";

  else{
    document.getElementById("show").innerHTML = "<b>"+ "Error Rate: (fp + fn) / (tp + fn + tp + tn)" + " ; " +
                                                "Precisione: tp / (tp + fp)" + "<br/>" + "<br/>" +
                                                "Accuratezza: (tp + tn) / (tp + fn + fp + tn)" +  " ; " +
                                                "Recall: tp / (tp + fn)" + "<br/>" + "</br>" +
                                                "Specificita': tn / (tn + fp)" +  " ; "  + 
                                                "False Positive Rate: 1 - specificita'" + "<br/>" + "<br/>" + 
												                        "F-Score: (2 * Recall * Precisione) / (Recall + Precisione)" + "<br/>" + "<br/>" + 
                                                "Efficienza modello: (err. no modello - err. con modello) / err. no modello" +  "<br/>" + "<br/>" + 
                                                "Probabilita' classificazione errata: 1 - Accuratezza </b>";
												 
                                        
  }
}

function setLearner(n){
  lrn=learners[n]
  trained=false;
  train();
  sql();
  nCluster();
  conf_matrix();
  prob();
  odds();
  valMod();
  goodMod();
  class_err();
  show();
}

</script>


</body>
</html>